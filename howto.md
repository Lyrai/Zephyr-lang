Для того, чтобы использовать возможности генерации кода Roslyn для начала необходимо сделать видимыми в вашем проекте `internal` члены Roslyn. Для этого в `.csproj` файлах проектов `Microsoft.CodeAnalysis.CSharp` и `Microsoft.CodeAnalysis` нужно добавить строку 
```
<InternalsVisibleTo Include="<Project name>" />
```
и добавить эти проекты к вашему решению. 

Также, в файле `.csproj` файле вашего проекта необходимо добавить строки
```
<RootNamespace>Zephyr</RootNamespace>
<StartupObject>Zephyr.Program</StartupObject>
```
Структура файлов должна повторять структуру в данном репозитории.

Перед началом генерации кода необходимо создать объект `CSharpCompilation`, в котором будет храниться вся информация о компиляции:
``` Непосре
_compilation = CSharpCompilation.Create(assemblyName).WithReferences(
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),  // Обязательная ссылка на mscorlib для .NET Framework либо System.Private.CoreLib для .NET
            MetadataReference.CreateFromFile(Assembly.Load("System.Console").Location),  // Ссылки далее необязательны для минимальной работы
            MetadataReference.CreateFromFile(Assembly.Load("System.Runtime").Location)
        );
```

Первым этапом генерации кода является создание символов. Так как классы символов Roslyn требуют синтаксическое дерево, были созданы классы-обертки `ZephyrMethodSymbol`, `ZephyrParameterSymbol` и `ZephyrFieldSymbol`. Создавать вручную символы классов нет необходимости, так как Roslyn делает это автоматически. Символы классов и пространств имен создаются из объектов `Declaration`. Для создания `Declaration` класса необходимо получить имена всех его членов, а также его локацию. Так как класс локации Roslyn требует синтаксическое дерево, была создана обертка `ZephyrSourceLocation`. Для создания `Declaration` пространства имен нужны `Declaration` всех его классов.

После того, как декларации получены, можно приступать к созданию символов. Символы создаются сверху вниз, то есть сначала создается символ пространства имен, затем символы классов, затем символы членов этих классов. После создания символа пространства имен, символы его членов создаются автоматически. При создании символов методов и полей символы классов необходимо получать с помощью метода `GetMembers` символа пространства имен. После создания символов всех членов класса необходимо этот класс заполнить этими символами. Для этого был создан метод `SetMembersDictionary`, принимающий словарь, где ключ - имя члена, значение - массив символов, имеющих это имя. После заполнения символа класса, необходимо сбросить и правильно заполнить его внутренние таблицы. Для этого используются методы `ResetMembersAndInitializers` и `GetMembersAndInitializers` символа класса.

После того, как все символы созданы и заполнены, необходимо установить глобальное пространство имен. Для этого был создан метод `SetGlobalNamespace` класса `SourceModuleSymbol`.

Далее необходимо получить `PEModuleBuilder` и установить точку входа. `PEModuleBuilder` возвращается методом `CreateModuleBuilder` класса `CSharpCompilation`, точка входа устанавливается методом `SetPEEntryPoint` класса `PEModuleBuilder`. Затем нужно скомпилировать синтезированные классы. Это делается методом `CompileSynthesizedMethods` класса `MethodCompiler`. Сами классы получаются вызовом `GetEmbeddedTypes` от `PEModuleBuilder`. После этого можно приступать к генерации кода ваших классов.

Непосредствено генерация кода выполняется объектом класса `ILBuilder`, который предоставляет различные API для генерации IL-кода. Генерация выполняется для каждого метода отдельно. После завершения генерации, сгенерированный код можно получить из свойства `RealizedIL` объекта `ILBuilder` после вызова метода `Realize`. Из полученного IL-кода необходимо создать объект `MethodBody` и установить сгенерированное тело метода его символу. Для этого используется метод `SetMethodBody` объета `PEModuleBuilder`.

После того, как генерация кода для всех классов завершена, необходимо сериализовать сгенерированную программу в исполняемый файл. Для этого используется метод `SerializeToPeStream` объекта `CSharpCompilation`. Также, если компиляция выполняется для .NET 6+, необходимо сгенерировать файл `<exe name>.runtimeconfig.json` следующего содержания:
```
{
    "runtimeOptions": {
        "tfm": "net6.0",
        "framework": {
            "name": "Microsoft.NETCore.App",
            "version": "<.NET version>"
        }
    }
}
```
